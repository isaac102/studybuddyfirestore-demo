{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { Deferred } from './promise';\nimport { Code, FirestoreError } from './error';\n/**\n * Wellknown \"timer\" IDs used when scheduling delayed operations on the\n * AsyncQueue. These IDs can then be used from tests to check for the presence\n * of operations or to run them early.\n *\n * The string values are used when encoding these timer IDs in JSON spec tests.\n */\n\nexport var TimerId;\n\n(function (TimerId) {\n  /** All can be used with runDelayedOperationsEarly() to run all timers. */\n  TimerId[\"All\"] = \"all\";\n  /**\n   * The following 4 timers are used in persistent_stream.ts for the listen and\n   * write streams. The \"Idle\" timer is used to close the stream due to\n   * inactivity. The \"ConnectionBackoff\" timer is used to restart a stream once\n   * the appropriate backoff delay has elapsed.\n   */\n\n  TimerId[\"ListenStreamIdle\"] = \"listen_stream_idle\";\n  TimerId[\"ListenStreamConnectionBackoff\"] = \"listen_stream_connection_backoff\";\n  TimerId[\"WriteStreamIdle\"] = \"write_stream_idle\";\n  TimerId[\"WriteStreamConnectionBackoff\"] = \"write_stream_connection_backoff\";\n  /**\n   * A timer used in online_state_tracker.ts to transition from\n   * OnlineState.Unknown to Offline after a set timeout, rather than waiting\n   * indefinitely for success or failure.\n   */\n\n  TimerId[\"OnlineStateTimeout\"] = \"online_state_timeout\";\n})(TimerId || (TimerId = {}));\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n */\n\n\nvar DelayedOperation =\n/** @class */\nfunction () {\n  function DelayedOperation(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\n    this.asyncQueue = asyncQueue;\n    this.timerId = timerId;\n    this.targetTimeMs = targetTimeMs;\n    this.op = op;\n    this.removalCallback = removalCallback;\n    this.deferred = new Deferred();\n    this.then = this.deferred.promise.then.bind(this.deferred.promise);\n    this.catch = this.deferred.promise.catch.bind(this.deferred.promise); // It's normal for the deferred promise to be canceled (due to cancellation)\n    // and so we attach a dummy catch callback to avoid\n    // 'UnhandledPromiseRejectionWarning' log spam.\n\n    this.deferred.promise.catch(function (err) {});\n  }\n  /**\n   * Creates and returns a DelayedOperation that has been scheduled to be\n   * executed on the provided asyncQueue after the provided delayMs.\n   *\n   * @param asyncQueue The queue to schedule the operation on.\n   * @param id A Timer ID identifying the type of operation this is.\n   * @param delayMs The delay (ms) before the operation should be scheduled.\n   * @param op The operation to run.\n   * @param removalCallback A callback to be called synchronously once the\n   *   operation is executed or canceled, notifying the AsyncQueue to remove it\n   *   from its delayedOperations list.\n   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n   *   the DelayedOperation class public.\n   */\n\n\n  DelayedOperation.createAndSchedule = function (asyncQueue, timerId, delayMs, op, removalCallback) {\n    var targetTime = Date.now() + delayMs;\n    var delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n    delayedOp.start(delayMs);\n    return delayedOp;\n  };\n  /**\n   * Starts the timer. This is called immediately after construction by\n   * createAndSchedule().\n   */\n\n\n  DelayedOperation.prototype.start = function (delayMs) {\n    var _this = this;\n\n    this.timerHandle = setTimeout(function () {\n      return _this.handleDelayElapsed();\n    }, delayMs);\n  };\n  /**\n   * Queues the operation to run immediately (if it hasn't already been run or\n   * canceled).\n   */\n\n\n  DelayedOperation.prototype.skipDelay = function () {\n    return this.handleDelayElapsed();\n  };\n  /**\n   * Cancels the operation if it hasn't already been executed or canceled. The\n   * promise will be rejected.\n   *\n   * As long as the operation has not yet been run, calling cancel() provides a\n   * guarantee that the operation will not be run.\n   */\n\n\n  DelayedOperation.prototype.cancel = function (reason) {\n    if (this.timerHandle !== null) {\n      this.clearTimeout();\n      this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\n    }\n  };\n\n  DelayedOperation.prototype.handleDelayElapsed = function () {\n    var _this = this;\n\n    this.asyncQueue.enqueue(function () {\n      if (_this.timerHandle !== null) {\n        _this.clearTimeout();\n\n        return _this.op().then(function (result) {\n          return _this.deferred.resolve(result);\n        });\n      } else {\n        return Promise.resolve();\n      }\n    });\n  };\n\n  DelayedOperation.prototype.clearTimeout = function () {\n    if (this.timerHandle !== null) {\n      this.removalCallback(this);\n      clearTimeout(this.timerHandle);\n      this.timerHandle = null;\n    }\n  };\n\n  return DelayedOperation;\n}();\n\nvar AsyncQueue =\n/** @class */\nfunction () {\n  function AsyncQueue() {\n    // The last promise in the queue.\n    this.tail = Promise.resolve(); // Operations scheduled to be queued in the future. Operations are\n    // automatically removed after they are run or canceled.\n\n    this.delayedOperations = []; // Flag set while there's an outstanding AsyncQueue operation, used for\n    // assertion sanity-checks.\n\n    this.operationInProgress = false;\n  }\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   */\n\n\n  AsyncQueue.prototype.enqueue = function (op) {\n    var _this = this;\n\n    this.verifyNotFailed();\n    var newTail = this.tail.then(function () {\n      _this.operationInProgress = true;\n      return op().catch(function (error) {\n        _this.failure = error;\n        _this.operationInProgress = false;\n        var message = error.stack || error.message || '';\n        log.error('INTERNAL UNHANDLED ERROR: ', message); // Escape the promise chain and throw the error globally so that\n        // e.g. any global crash reporting library detects and reports it.\n        // (but not for simulated errors in our tests since this breaks mocha)\n\n        if (message.indexOf('Firestore Test Simulated Error') < 0) {\n          setTimeout(function () {\n            throw error;\n          }, 0);\n        } // Re-throw the error so that this.tail becomes a rejected Promise and\n        // all further attempts to chain (via .then) will just short-circuit\n        // and return the rejected Promise.\n\n\n        throw error;\n      }).then(function (result) {\n        _this.operationInProgress = false;\n        return result;\n      });\n    });\n    this.tail = newTail;\n    return newTail;\n  };\n  /**\n   * Schedules an operation to be queued on the AsyncQueue once the specified\n   * `delayMs` has elapsed. The returned CancelablePromise can be used to cancel\n   * the operation prior to its running.\n   */\n\n\n  AsyncQueue.prototype.enqueueAfterDelay = function (timerId, delayMs, op) {\n    var _this = this;\n\n    this.verifyNotFailed(); // While not necessarily harmful, we currently don't expect to have multiple\n    // ops with the same timer id in the queue, so defensively reject them.\n\n    assert(!this.containsDelayedOperation(timerId), \"Attempted to schedule multiple operations with timer id \" + timerId + \".\");\n    var delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function (op) {\n      return _this.removeDelayedOperation(op);\n    });\n    this.delayedOperations.push(delayedOp);\n    return delayedOp;\n  };\n\n  AsyncQueue.prototype.verifyNotFailed = function () {\n    if (this.failure) {\n      fail('AsyncQueue is already failed: ' + (this.failure.stack || this.failure.message));\n    }\n  };\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n\n\n  AsyncQueue.prototype.verifyOperationInProgress = function () {\n    assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');\n  };\n  /**\n   * Waits until all currently queued tasks are finished executing. Delayed\n   * operations are not run.\n   */\n\n\n  AsyncQueue.prototype.drain = function () {\n    return this.enqueue(function () {\n      return Promise.resolve();\n    });\n  };\n  /**\n   * For Tests: Determine if a delayed operation with a particular TimerId\n   * exists.\n   */\n\n\n  AsyncQueue.prototype.containsDelayedOperation = function (timerId) {\n    return this.delayedOperations.findIndex(function (op) {\n      return op.timerId === timerId;\n    }) >= 0;\n  };\n  /**\n   * For Tests: Runs some or all delayed operations early.\n   *\n   * @param lastTimerId Delayed operations up to and including this TimerId will\n   *  be drained. Throws if no such operation exists. Pass TimerId.All to run\n   *  all delayed operations.\n   * @returns a Promise that resolves once all operations have been run.\n   */\n\n\n  AsyncQueue.prototype.runDelayedOperationsEarly = function (lastTimerId) {\n    var _this = this; // Note that draining may generate more delayed ops, so we do that first.\n\n\n    return this.drain().then(function () {\n      assert(lastTimerId === TimerId.All || _this.containsDelayedOperation(lastTimerId), \"Attempted to drain to missing operation \" + lastTimerId); // Run ops in the same order they'd run if they ran naturally.\n\n      _this.delayedOperations.sort(function (a, b) {\n        return a.targetTimeMs - b.targetTimeMs;\n      });\n\n      for (var _i = 0, _a = _this.delayedOperations; _i < _a.length; _i++) {\n        var op = _a[_i];\n        op.skipDelay();\n\n        if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) {\n          break;\n        }\n      }\n\n      return _this.drain();\n    });\n  };\n  /** Called once a DelayedOperation is run or canceled. */\n\n\n  AsyncQueue.prototype.removeDelayedOperation = function (op) {\n    // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n    var index = this.delayedOperations.indexOf(op);\n    assert(index >= 0, 'Delayed operation not found.');\n    this.delayedOperations.splice(index, 1);\n  };\n\n  return AsyncQueue;\n}();\n\nexport { AsyncQueue };","map":{"version":3,"sources":["../src/util/async_queue.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { AnyJs } from './misc';\nimport { Deferred, CancelablePromise } from './promise';\nimport { Code, FirestoreError } from './error';\n\n// tslint:disable-next-line:no-any Accept any return type from setTimeout().\ntype TimerHandle = any;\n\n/**\n * Wellknown \"timer\" IDs used when scheduling delayed operations on the\n * AsyncQueue. These IDs can then be used from tests to check for the presence\n * of operations or to run them early.\n *\n * The string values are used when encoding these timer IDs in JSON spec tests.\n */\nexport enum TimerId {\n  /** All can be used with runDelayedOperationsEarly() to run all timers. */\n  All = 'all',\n\n  /**\n   * The following 4 timers are used in persistent_stream.ts for the listen and\n   * write streams. The \"Idle\" timer is used to close the stream due to\n   * inactivity. The \"ConnectionBackoff\" timer is used to restart a stream once\n   * the appropriate backoff delay has elapsed.\n   */\n  ListenStreamIdle = 'listen_stream_idle',\n  ListenStreamConnectionBackoff = 'listen_stream_connection_backoff',\n  WriteStreamIdle = 'write_stream_idle',\n  WriteStreamConnectionBackoff = 'write_stream_connection_backoff',\n\n  /**\n   * A timer used in online_state_tracker.ts to transition from\n   * OnlineState.Unknown to Offline after a set timeout, rather than waiting\n   * indefinitely for success or failure.\n   */\n  OnlineStateTimeout = 'online_state_timeout'\n}\n\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n */\nclass DelayedOperation<T> implements CancelablePromise<T> {\n  // handle for use with clearTimeout(), or null if the operation has been\n  // executed or canceled already.\n  private timerHandle: TimerHandle | null;\n\n  private readonly deferred = new Deferred<T>();\n\n  private constructor(\n    private readonly asyncQueue: AsyncQueue,\n    readonly timerId: TimerId,\n    readonly targetTimeMs: number,\n    private readonly op: () => Promise<T>,\n    private readonly removalCallback: (op: DelayedOperation<T>) => void\n  ) {\n    // It's normal for the deferred promise to be canceled (due to cancellation)\n    // and so we attach a dummy catch callback to avoid\n    // 'UnhandledPromiseRejectionWarning' log spam.\n    this.deferred.promise.catch(err => {});\n  }\n\n  /**\n   * Creates and returns a DelayedOperation that has been scheduled to be\n   * executed on the provided asyncQueue after the provided delayMs.\n   *\n   * @param asyncQueue The queue to schedule the operation on.\n   * @param id A Timer ID identifying the type of operation this is.\n   * @param delayMs The delay (ms) before the operation should be scheduled.\n   * @param op The operation to run.\n   * @param removalCallback A callback to be called synchronously once the\n   *   operation is executed or canceled, notifying the AsyncQueue to remove it\n   *   from its delayedOperations list.\n   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n   *   the DelayedOperation class public.\n   */\n  static createAndSchedule<T>(\n    asyncQueue: AsyncQueue,\n    timerId: TimerId,\n    delayMs: number,\n    op: () => Promise<T>,\n    removalCallback: (op: DelayedOperation<T>) => void\n  ): DelayedOperation<T> {\n    const targetTime = Date.now() + delayMs;\n    const delayedOp = new DelayedOperation(\n      asyncQueue,\n      timerId,\n      targetTime,\n      op,\n      removalCallback\n    );\n    delayedOp.start(delayMs);\n    return delayedOp;\n  }\n\n  /**\n   * Starts the timer. This is called immediately after construction by\n   * createAndSchedule().\n   */\n  private start(delayMs: number): void {\n    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\n  }\n\n  /**\n   * Queues the operation to run immediately (if it hasn't already been run or\n   * canceled).\n   */\n  skipDelay(): void {\n    return this.handleDelayElapsed();\n  }\n\n  /**\n   * Cancels the operation if it hasn't already been executed or canceled. The\n   * promise will be rejected.\n   *\n   * As long as the operation has not yet been run, calling cancel() provides a\n   * guarantee that the operation will not be run.\n   */\n  cancel(reason?: string): void {\n    if (this.timerHandle !== null) {\n      this.clearTimeout();\n      this.deferred.reject(\n        new FirestoreError(\n          Code.CANCELLED,\n          'Operation cancelled' + (reason ? ': ' + reason : '')\n        )\n      );\n    }\n  }\n\n  // Promise implementation.\n  readonly [Symbol.toStringTag]: 'Promise';\n  then = this.deferred.promise.then.bind(this.deferred.promise);\n  catch = this.deferred.promise.catch.bind(this.deferred.promise);\n\n  private handleDelayElapsed(): void {\n    this.asyncQueue.enqueue(() => {\n      if (this.timerHandle !== null) {\n        this.clearTimeout();\n        return this.op().then(result => {\n          return this.deferred.resolve(result);\n        });\n      } else {\n        return Promise.resolve();\n      }\n    });\n  }\n\n  private clearTimeout() {\n    if (this.timerHandle !== null) {\n      this.removalCallback(this);\n      clearTimeout(this.timerHandle);\n      this.timerHandle = null;\n    }\n  }\n}\n\nexport class AsyncQueue {\n  // The last promise in the queue.\n  private tail: Promise<AnyJs | void> = Promise.resolve();\n\n  // Operations scheduled to be queued in the future. Operations are\n  // automatically removed after they are run or canceled.\n  private delayedOperations: Array<DelayedOperation<AnyJs>> = [];\n\n  // visible for testing\n  failure: Error;\n\n  // Flag set while there's an outstanding AsyncQueue operation, used for\n  // assertion sanity-checks.\n  private operationInProgress = false;\n\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   */\n  enqueue<T>(op: () => Promise<T>): Promise<T> {\n    this.verifyNotFailed();\n    const newTail = this.tail.then(() => {\n      this.operationInProgress = true;\n      return op()\n        .catch(error => {\n          this.failure = error;\n          this.operationInProgress = false;\n          const message = error.stack || error.message || '';\n          log.error('INTERNAL UNHANDLED ERROR: ', message);\n\n          // Escape the promise chain and throw the error globally so that\n          // e.g. any global crash reporting library detects and reports it.\n          // (but not for simulated errors in our tests since this breaks mocha)\n          if (message.indexOf('Firestore Test Simulated Error') < 0) {\n            setTimeout(() => {\n              throw error;\n            }, 0);\n          }\n\n          // Re-throw the error so that this.tail becomes a rejected Promise and\n          // all further attempts to chain (via .then) will just short-circuit\n          // and return the rejected Promise.\n          throw error;\n        })\n        .then(result => {\n          this.operationInProgress = false;\n          return result;\n        });\n    });\n    this.tail = newTail;\n    return newTail;\n  }\n\n  /**\n   * Schedules an operation to be queued on the AsyncQueue once the specified\n   * `delayMs` has elapsed. The returned CancelablePromise can be used to cancel\n   * the operation prior to its running.\n   */\n  enqueueAfterDelay<T>(\n    timerId: TimerId,\n    delayMs: number,\n    op: () => Promise<T>\n  ): CancelablePromise<T> {\n    this.verifyNotFailed();\n\n    // While not necessarily harmful, we currently don't expect to have multiple\n    // ops with the same timer id in the queue, so defensively reject them.\n    assert(\n      !this.containsDelayedOperation(timerId),\n      `Attempted to schedule multiple operations with timer id ${timerId}.`\n    );\n\n    const delayedOp = DelayedOperation.createAndSchedule(\n      this,\n      timerId,\n      delayMs,\n      op,\n      op => this.removeDelayedOperation(op)\n    );\n    this.delayedOperations.push(delayedOp);\n\n    return delayedOp;\n  }\n\n  private verifyNotFailed(): void {\n    if (this.failure) {\n      fail(\n        'AsyncQueue is already failed: ' +\n          (this.failure.stack || this.failure.message)\n      );\n    }\n  }\n\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n  verifyOperationInProgress(): void {\n    assert(\n      this.operationInProgress,\n      'verifyOpInProgress() called when no op in progress on this queue.'\n    );\n  }\n\n  /**\n   * Waits until all currently queued tasks are finished executing. Delayed\n   * operations are not run.\n   */\n  drain(): Promise<void> {\n    return this.enqueue(() => Promise.resolve());\n  }\n\n  /**\n   * For Tests: Determine if a delayed operation with a particular TimerId\n   * exists.\n   */\n  containsDelayedOperation(timerId: TimerId): boolean {\n    return this.delayedOperations.findIndex(op => op.timerId === timerId) >= 0;\n  }\n\n  /**\n   * For Tests: Runs some or all delayed operations early.\n   *\n   * @param lastTimerId Delayed operations up to and including this TimerId will\n   *  be drained. Throws if no such operation exists. Pass TimerId.All to run\n   *  all delayed operations.\n   * @returns a Promise that resolves once all operations have been run.\n   */\n  runDelayedOperationsEarly(lastTimerId: TimerId): Promise<void> {\n    // Note that draining may generate more delayed ops, so we do that first.\n    return this.drain().then(() => {\n      assert(\n        lastTimerId === TimerId.All ||\n          this.containsDelayedOperation(lastTimerId),\n        `Attempted to drain to missing operation ${lastTimerId}`\n      );\n\n      // Run ops in the same order they'd run if they ran naturally.\n      this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\n\n      for (const op of this.delayedOperations) {\n        op.skipDelay();\n        if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) {\n          break;\n        }\n      }\n\n      return this.drain();\n    });\n  }\n\n  /** Called once a DelayedOperation is run or canceled. */\n  private removeDelayedOperation<T>(op: DelayedOperation<T>) {\n    // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n    const index = this.delayedOperations.indexOf(op);\n    assert(index >= 0, 'Delayed operation not found.');\n    this.delayedOperations.splice(index, 1);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}