{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistentListenStream, PersistentWriteStream } from './persistent_stream';\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\n\nvar Datastore =\n/** @class */\nfunction () {\n  function Datastore(queue, connection, credentials, serializer) {\n    this.queue = queue;\n    this.connection = connection;\n    this.credentials = credentials;\n    this.serializer = serializer;\n  }\n\n  Datastore.prototype.newPersistentWriteStream = function () {\n    return new PersistentWriteStream(this.queue, this.connection, this.credentials, this.serializer);\n  };\n\n  Datastore.prototype.newPersistentWatchStream = function () {\n    return new PersistentListenStream(this.queue, this.connection, this.credentials, this.serializer);\n  };\n\n  Datastore.prototype.commit = function (mutations) {\n    var _this = this;\n\n    var params = {\n      database: this.serializer.encodedDatabaseId,\n      writes: mutations.map(function (m) {\n        return _this.serializer.toMutation(m);\n      })\n    };\n    return this.invokeRPC('Commit', params).then(function (response) {\n      return _this.serializer.fromWriteResults(response.writeResults);\n    });\n  };\n\n  Datastore.prototype.lookup = function (keys) {\n    var _this = this;\n\n    var params = {\n      database: this.serializer.encodedDatabaseId,\n      documents: keys.map(function (k) {\n        return _this.serializer.toName(k);\n      })\n    };\n    return this.invokeStreamingRPC('BatchGetDocuments', params).then(function (response) {\n      var docs = maybeDocumentMap();\n      response.forEach(function (proto) {\n        var doc = _this.serializer.fromMaybeDocument(proto);\n\n        docs = docs.insert(doc.key, doc);\n      });\n      var result = [];\n      keys.forEach(function (key) {\n        var doc = docs.get(key);\n        assert(!!doc, 'Missing entity in write response for ' + key);\n        result.push(doc);\n      });\n      return result;\n    });\n  };\n  /** Gets an auth token and invokes the provided RPC. */\n\n\n  Datastore.prototype.invokeRPC = function (rpcName, request) {\n    var _this = this; // TODO(mikelehen): Retry (with backoff) on token failures?\n\n\n    return this.credentials.getToken(\n    /*forceRefresh=*/\n    false).then(function (token) {\n      return _this.connection.invokeRPC(rpcName, request, token);\n    });\n  };\n  /** Gets an auth token and invokes the provided RPC with streamed results. */\n\n\n  Datastore.prototype.invokeStreamingRPC = function (rpcName, request) {\n    var _this = this; // TODO(mikelehen): Retry (with backoff) on token failures?\n\n\n    return this.credentials.getToken(\n    /*forceRefresh=*/\n    false).then(function (token) {\n      return _this.connection.invokeStreamingRPC(rpcName, request, token);\n    });\n  };\n\n  return Datastore;\n}();\n\nexport { Datastore };","map":{"version":3,"sources":["../src/remote/datastore.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { CredentialsProvider } from '../api/credentials';\nimport { maybeDocumentMap } from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport { assert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\n\nimport { Connection } from './connection';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream\n} from './persistent_stream';\nimport { JsonProtoSerializer } from './serializer';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface BatchGetDocumentsRequest extends api.BatchGetDocumentsRequest {\n  database?: string;\n}\ninterface CommitRequest extends api.CommitRequest {\n  database?: string;\n}\n\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nexport class Datastore {\n  constructor(\n    private queue: AsyncQueue,\n    private connection: Connection,\n    private credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer\n  ) {}\n\n  newPersistentWriteStream(): PersistentWriteStream {\n    return new PersistentWriteStream(\n      this.queue,\n      this.connection,\n      this.credentials,\n      this.serializer\n    );\n  }\n\n  newPersistentWatchStream(): PersistentListenStream {\n    return new PersistentListenStream(\n      this.queue,\n      this.connection,\n      this.credentials,\n      this.serializer\n    );\n  }\n\n  commit(mutations: Mutation[]): Promise<MutationResult[]> {\n    const params: CommitRequest = {\n      database: this.serializer.encodedDatabaseId,\n      writes: mutations.map(m => this.serializer.toMutation(m))\n    };\n    return this.invokeRPC<CommitRequest, api.CommitResponse>(\n      'Commit',\n      params\n    ).then(response => {\n      return this.serializer.fromWriteResults(response.writeResults);\n    });\n  }\n\n  lookup(keys: DocumentKey[]): Promise<MaybeDocument[]> {\n    const params: BatchGetDocumentsRequest = {\n      database: this.serializer.encodedDatabaseId,\n      documents: keys.map(k => this.serializer.toName(k))\n    };\n    return this.invokeStreamingRPC<\n      BatchGetDocumentsRequest,\n      api.BatchGetDocumentsResponse\n    >('BatchGetDocuments', params).then(response => {\n      let docs = maybeDocumentMap();\n      response.forEach(proto => {\n        const doc = this.serializer.fromMaybeDocument(proto);\n        docs = docs.insert(doc.key, doc);\n      });\n      const result: MaybeDocument[] = [];\n      keys.forEach(key => {\n        const doc = docs.get(key);\n        assert(!!doc, 'Missing entity in write response for ' + key);\n        result.push(doc!);\n      });\n      return result;\n    });\n  }\n\n  /** Gets an auth token and invokes the provided RPC. */\n  private invokeRPC<Req, Resp>(rpcName: string, request: Req): Promise<Resp> {\n    // TODO(mikelehen): Retry (with backoff) on token failures?\n    return this.credentials.getToken(/*forceRefresh=*/ false).then(token => {\n      return this.connection.invokeRPC<Req, Resp>(rpcName, request, token);\n    });\n  }\n\n  /** Gets an auth token and invokes the provided RPC with streamed results. */\n  private invokeStreamingRPC<Req, Resp>(\n    rpcName: string,\n    request: Req\n  ): Promise<Resp[]> {\n    // TODO(mikelehen): Retry (with backoff) on token failures?\n    return this.credentials.getToken(/*forceRefresh=*/ false).then(token => {\n      return this.connection.invokeStreamingRPC<Req, Resp>(\n        rpcName,\n        request,\n        token\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}