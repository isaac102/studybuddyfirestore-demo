{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ObjectMap } from '../util/obj_map';\nimport { PersistencePromise } from './persistence_promise';\nimport { ReferenceSet } from './reference_set';\nimport { assert } from '../util/assert';\n\nvar MemoryQueryCache =\n/** @class */\nfunction () {\n  function MemoryQueryCache() {\n    /**\n     * Maps a query to the data about that query\n     */\n    this.queries = new ObjectMap(function (q) {\n      return q.canonicalId();\n    });\n    /** The last received snapshot version. */\n\n    this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n    /** The highest numbered target ID encountered. */\n\n    this.highestTargetId = 0;\n    /**\n     * A ordered bidirectional mapping between documents and the remote target\n     * IDs.\n     */\n\n    this.references = new ReferenceSet();\n    this.targetCount = 0;\n  }\n\n  MemoryQueryCache.prototype.start = function (transaction) {\n    // Nothing to do.\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n    return this.lastRemoteSnapshotVersion;\n  };\n\n  MemoryQueryCache.prototype.getHighestTargetId = function () {\n    return this.highestTargetId;\n  };\n\n  MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.saveQueryData = function (queryData) {\n    this.queries.set(queryData.query, queryData);\n    var targetId = queryData.targetId;\n\n    if (targetId > this.highestTargetId) {\n      this.highestTargetId = targetId;\n    } // TODO(GC): track sequence number\n\n  };\n\n  MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {\n    assert(!this.queries.has(queryData.query), 'Adding a query that already exists');\n    this.saveQueryData(queryData);\n    this.targetCount += 1;\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.updateQueryData = function (transaction, queryData) {\n    assert(this.queries.has(queryData.query), 'Updating a non-existent query');\n    this.saveQueryData(queryData);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n    assert(this.targetCount > 0, 'Removing a target from an empty cache');\n    assert(this.queries.has(queryData.query), 'Removing a non-existent target from the cache');\n    this.queries.delete(queryData.query);\n    this.references.removeReferencesForId(queryData.targetId);\n    this.targetCount -= 1;\n    return PersistencePromise.resolve();\n  };\n\n  Object.defineProperty(MemoryQueryCache.prototype, \"count\", {\n    get: function () {\n      return this.targetCount;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MemoryQueryCache.prototype.getQueryData = function (transaction, query) {\n    var queryData = this.queries.get(query) || null;\n    return PersistencePromise.resolve(queryData);\n  };\n\n  MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n    this.references.addReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n    this.references.removeReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n    this.references.removeReferencesForId(targetId);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n    var matchingKeys = this.references.referencesForId(targetId);\n    return PersistencePromise.resolve(matchingKeys);\n  };\n\n  MemoryQueryCache.prototype.setGarbageCollector = function (gc) {\n    this.references.setGarbageCollector(gc);\n  };\n\n  MemoryQueryCache.prototype.containsKey = function (txn, key) {\n    return this.references.containsKey(txn, key);\n  };\n\n  return MemoryQueryCache;\n}();\n\nexport { MemoryQueryCache };","map":{"version":3,"sources":["../src/local/memory_query_cache.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetId } from '../core/types';\nimport { DocumentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { ObjectMap } from '../util/obj_map';\n\nimport { GarbageCollector } from './garbage_collector';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryCache } from './query_cache';\nimport { QueryData } from './query_data';\nimport { ReferenceSet } from './reference_set';\nimport { assert } from '../util/assert';\n\nexport class MemoryQueryCache implements QueryCache {\n  /**\n   * Maps a query to the data about that query\n   */\n  private queries = new ObjectMap<Query, QueryData>(q => q.canonicalId());\n\n  /** The last received snapshot version. */\n  private lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n  /** The highest numbered target ID encountered. */\n  private highestTargetId: TargetId = 0;\n  /**\n   * A ordered bidirectional mapping between documents and the remote target\n   * IDs.\n   */\n  private references = new ReferenceSet();\n\n  private targetCount = 0;\n\n  start(transaction: PersistenceTransaction): PersistencePromise<void> {\n    // Nothing to do.\n    return PersistencePromise.resolve();\n  }\n\n  getLastRemoteSnapshotVersion(): SnapshotVersion {\n    return this.lastRemoteSnapshotVersion;\n  }\n\n  getHighestTargetId(): TargetId {\n    return this.highestTargetId;\n  }\n\n  setLastRemoteSnapshotVersion(\n    transaction: PersistenceTransaction,\n    snapshotVersion: SnapshotVersion\n  ): PersistencePromise<void> {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    return PersistencePromise.resolve();\n  }\n\n  private saveQueryData(queryData: QueryData) {\n    this.queries.set(queryData.query, queryData);\n    const targetId = queryData.targetId;\n    if (targetId > this.highestTargetId) {\n      this.highestTargetId = targetId;\n    }\n    // TODO(GC): track sequence number\n  }\n\n  addQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    assert(\n      !this.queries.has(queryData.query),\n      'Adding a query that already exists'\n    );\n    this.saveQueryData(queryData);\n    this.targetCount += 1;\n    return PersistencePromise.resolve();\n  }\n\n  updateQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    assert(this.queries.has(queryData.query), 'Updating a non-existent query');\n    this.saveQueryData(queryData);\n    return PersistencePromise.resolve();\n  }\n\n  removeQueryData(\n    transaction: PersistenceTransaction,\n    queryData: QueryData\n  ): PersistencePromise<void> {\n    assert(this.targetCount > 0, 'Removing a target from an empty cache');\n    assert(\n      this.queries.has(queryData.query),\n      'Removing a non-existent target from the cache'\n    );\n    this.queries.delete(queryData.query);\n    this.references.removeReferencesForId(queryData.targetId);\n    this.targetCount -= 1;\n    return PersistencePromise.resolve();\n  }\n\n  get count(): number {\n    return this.targetCount;\n  }\n\n  getQueryData(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<QueryData | null> {\n    const queryData = this.queries.get(query) || null;\n    return PersistencePromise.resolve(queryData);\n  }\n\n  addMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.addReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  }\n\n  removeMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.removeReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  }\n\n  removeMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.removeReferencesForId(targetId);\n    return PersistencePromise.resolve();\n  }\n\n  getMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<DocumentKeySet> {\n    const matchingKeys = this.references.referencesForId(targetId);\n    return PersistencePromise.resolve(matchingKeys);\n  }\n\n  setGarbageCollector(gc: GarbageCollector | null): void {\n    this.references.setGarbageCollector(gc);\n  }\n\n  containsKey(\n    txn: PersistenceTransaction | null,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    return this.references.containsKey(txn, key);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}