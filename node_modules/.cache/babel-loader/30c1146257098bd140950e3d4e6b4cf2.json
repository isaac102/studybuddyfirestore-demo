{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as log from '../util/log';\nvar LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\n\nvar ExponentialBackoff =\n/** @class */\nfunction () {\n  function ExponentialBackoff(\n  /**\n   * The AsyncQueue to run backoff operations on.\n   */\n  queue,\n  /**\n   * The ID to use when scheduling backoff operations on the AsyncQueue.\n   */\n  timerId,\n  /**\n   * The initial delay (used as the base delay on the first retry attempt).\n   * Note that jitter will still be applied, so the actual delay could be as\n   * little as 0.5*initialDelayMs.\n   */\n  initialDelayMs,\n  /**\n   * The multiplier to use to determine the extended base delay after each\n   * attempt.\n   */\n  backoffFactor,\n  /**\n   * The maximum base delay after which no further backoff is performed.\n   * Note that jitter will still be applied, so the actual delay could be as\n   * much as 1.5*maxDelayMs.\n   */\n  maxDelayMs) {\n    this.queue = queue;\n    this.timerId = timerId;\n    this.initialDelayMs = initialDelayMs;\n    this.backoffFactor = backoffFactor;\n    this.maxDelayMs = maxDelayMs;\n    this.timerPromise = null;\n    this.reset();\n  }\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n\n\n  ExponentialBackoff.prototype.reset = function () {\n    this.currentBaseMs = 0;\n  };\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n\n\n  ExponentialBackoff.prototype.resetToMax = function () {\n    this.currentBaseMs = this.maxDelayMs;\n  };\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts. If there was a pending backoff operation\n   * already, it will be canceled.\n   */\n\n\n  ExponentialBackoff.prototype.backoffAndRun = function (op) {\n    // Cancel any pending backoff operation.\n    this.cancel(); // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n\n    var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n\n    if (this.currentBaseMs > 0) {\n      log.debug(LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" + (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n    }\n\n    this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, delayWithJitterMs, op); // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n\n    this.currentBaseMs *= this.backoffFactor;\n\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n  };\n\n  ExponentialBackoff.prototype.cancel = function () {\n    if (this.timerPromise !== null) {\n      this.timerPromise.cancel();\n      this.timerPromise = null;\n    }\n  };\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n\n\n  ExponentialBackoff.prototype.jitterDelayMs = function () {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  };\n\n  return ExponentialBackoff;\n}();\n\nexport { ExponentialBackoff };","map":{"version":3,"sources":["../src/remote/backoff.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;AAEH,OAAO,KAAK,GAAZ,MAAqB,aAArB;AAGA,IAAM,OAAO,GAAG,oBAAhB;AAEA;;;;;;;;AAQG;;AACH,IAAA,kBAAA;AAAA;AAAA,YAAA;AAIE,WAAA,kBAAA;AACE;;AAEG;AACc,EAAA,KAJnB;AAKE;;AAEG;AACc,EAAA,OARnB;AASE;;;;AAIG;AACc,EAAA,cAdnB;AAeE;;;AAGG;AACc,EAAA,aAnBnB;AAoBE;;;;AAIG;AACc,EAAA,UAzBnB,EAyBqC;AArBlB,SAAA,KAAA,GAAA,KAAA;AAIA,SAAA,OAAA,GAAA,OAAA;AAMA,SAAA,cAAA,GAAA,cAAA;AAKA,SAAA,aAAA,GAAA,aAAA;AAMA,SAAA,UAAA,GAAA,UAAA;AA3BX,SAAA,YAAA,GAA+C,IAA/C;AA6BN,SAAK,KAAL;AACD;AAED;;;;;;AAMG;;;AACH,EAAA,kBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACE,SAAK,aAAL,GAAqB,CAArB;AACD,GAFD;AAIA;;;AAGG;;;AACH,EAAA,kBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,SAAK,aAAL,GAAqB,KAAK,UAA1B;AACD,GAFD;AAIA;;;;AAIG;;;AACH,EAAA,kBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,EAAd,EAAqC;AACnC;AACA,SAAK,MAAL,GAFmC,CAInC;AACA;;AACA,QAAM,iBAAiB,GAAG,KAAK,aAAL,GAAqB,KAAK,aAAL,EAA/C;;AACA,QAAI,KAAK,aAAL,GAAqB,CAAzB,EAA4B;AAC1B,MAAA,GAAG,CAAC,KAAJ,CACE,OADF,EAEE,qBAAmB,iBAAnB,GAAoC,MAApC,IACE,kBAAgB,KAAK,aAArB,GAAkC,MADpC,CAFF;AAKD;;AACD,SAAK,YAAL,GAAoB,KAAK,KAAL,CAAW,iBAAX,CAClB,KAAK,OADa,EAElB,iBAFkB,EAGlB,EAHkB,CAApB,CAdmC,CAoBnC;AACA;;AACA,SAAK,aAAL,IAAsB,KAAK,aAA3B;;AACA,QAAI,KAAK,aAAL,GAAqB,KAAK,cAA9B,EAA8C;AAC5C,WAAK,aAAL,GAAqB,KAAK,cAA1B;AACD;;AACD,QAAI,KAAK,aAAL,GAAqB,KAAK,UAA9B,EAA0C;AACxC,WAAK,aAAL,GAAqB,KAAK,UAA1B;AACD;AACF,GA7BD;;AA+BA,EAAA,kBAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AACE,QAAI,KAAK,YAAL,KAAsB,IAA1B,EAAgC;AAC9B,WAAK,YAAL,CAAkB,MAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACD;AACF,GALD;AAOA;;;AACQ,EAAA,kBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,YAAA;AACE,WAAO,CAAC,IAAI,CAAC,MAAL,KAAgB,GAAjB,IAAwB,KAAK,aAApC;AACD,GAFO;;AAGV,SAAA,kBAAA;AAAC,CApGD,EAAA","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as log from '../util/log';\nimport { CancelablePromise } from '../util/promise';\nimport { AsyncQueue, TimerId } from '../util/async_queue';\nconst LOG_TAG = 'ExponentialBackoff';\n\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nexport class ExponentialBackoff {\n  private currentBaseMs: number;\n  private timerPromise: CancelablePromise<void> | null = null;\n\n  constructor(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    private readonly queue: AsyncQueue,\n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    private readonly timerId: TimerId,\n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    private readonly initialDelayMs: number,\n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    private readonly backoffFactor: number,\n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    private readonly maxDelayMs: number\n  ) {\n    this.reset();\n  }\n\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n  reset(): void {\n    this.currentBaseMs = 0;\n  }\n\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n  resetToMax(): void {\n    this.currentBaseMs = this.maxDelayMs;\n  }\n\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts. If there was a pending backoff operation\n   * already, it will be canceled.\n   */\n  backoffAndRun(op: () => Promise<void>): void {\n    // Cancel any pending backoff operation.\n    this.cancel();\n\n    // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n    const delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n    if (this.currentBaseMs > 0) {\n      log.debug(\n        LOG_TAG,\n        `Backing off for ${delayWithJitterMs} ms ` +\n          `(base delay: ${this.currentBaseMs} ms)`\n      );\n    }\n    this.timerPromise = this.queue.enqueueAfterDelay(\n      this.timerId,\n      delayWithJitterMs,\n      op\n    );\n\n    // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n    this.currentBaseMs *= this.backoffFactor;\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n  }\n\n  cancel(): void {\n    if (this.timerPromise !== null) {\n      this.timerPromise.cancel();\n      this.timerPromise = null;\n    }\n  }\n\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n  private jitterDelayMs(): number {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}