{"ast":null,"code":"/**\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OnlineState } from '../core/types';\nimport * as log from '../util/log';\nimport { assert } from '../util/assert';\nimport { TimerId } from '../util/async_queue';\nvar LOG_TAG = 'OnlineStateTracker'; // To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\n\nvar MAX_WATCH_STREAM_FAILURES = 2; // To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\n\nvar ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\n\nvar OnlineStateTracker =\n/** @class */\nfunction () {\n  function OnlineStateTracker(asyncQueue, onlineStateHandler) {\n    this.asyncQueue = asyncQueue;\n    this.onlineStateHandler = onlineStateHandler;\n    /** The current OnlineState. */\n\n    this.state = OnlineState.Unknown;\n    /**\n     * A count of consecutive failures to open the stream. If it reaches the\n     * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n     * Offline.\n     */\n\n    this.watchStreamFailures = 0;\n    /**\n     * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n     * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n     * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n     */\n\n    this.onlineStateTimer = null;\n    /**\n     * Whether the client should log a warning message if it fails to connect to\n     * the backend (initially true, cleared after a successful stream, or if we've\n     * logged the message already).\n     */\n\n    this.shouldWarnClientIsOffline = true;\n  }\n  /**\n   * Called by RemoteStore when a watch stream is started.\n   *\n   * It sets the OnlineState to Unknown and starts the onlineStateTimer\n   * if necessary.\n   */\n\n\n  OnlineStateTracker.prototype.handleWatchStreamStart = function () {\n    var _this = this;\n\n    this.setAndBroadcast(OnlineState.Unknown);\n\n    if (this.onlineStateTimer === null) {\n      this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(TimerId.OnlineStateTimeout, ONLINE_STATE_TIMEOUT_MS, function () {\n        _this.onlineStateTimer = null;\n        assert(_this.state === OnlineState.Unknown, 'Timer should be canceled if we transitioned to a different state.');\n        log.debug(LOG_TAG, \"Watch stream didn't reach online or offline within \" + (ONLINE_STATE_TIMEOUT_MS + \"ms. Considering client offline.\"));\n\n        _this.logClientOfflineWarningIfNecessary();\n\n        _this.setAndBroadcast(OnlineState.Offline); // NOTE: handleWatchStreamFailure() will continue to increment\n        // watchStreamFailures even though we are already marked Offline,\n        // but this is non-harmful.\n\n\n        return Promise.resolve();\n      });\n    }\n  };\n  /**\n   * Updates our OnlineState as appropriate after the watch stream reports a\n   * failure. The first failure moves us to the 'Unknown' state. We then may\n   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n   * actually transition to the 'Offline' state.\n   */\n\n\n  OnlineStateTracker.prototype.handleWatchStreamFailure = function () {\n    if (this.state === OnlineState.Online) {\n      this.setAndBroadcast(OnlineState.Unknown);\n    } else {\n      this.watchStreamFailures++;\n\n      if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n        this.clearOnlineStateTimer();\n        this.logClientOfflineWarningIfNecessary();\n        this.setAndBroadcast(OnlineState.Offline);\n      }\n    }\n  };\n  /**\n   * Explicitly sets the OnlineState to the specified state.\n   *\n   * Note that this resets our timers / failure counters, etc. used by our\n   * Offline heuristics, so must not be used in place of\n   * handleWatchStreamStart() and handleWatchStreamFailure().\n   */\n\n\n  OnlineStateTracker.prototype.set = function (newState) {\n    this.clearOnlineStateTimer();\n    this.watchStreamFailures = 0;\n\n    if (newState === OnlineState.Online) {\n      // We've connected to watch at least once. Don't warn the developer\n      // about being offline going forward.\n      this.shouldWarnClientIsOffline = false;\n    }\n\n    this.setAndBroadcast(newState);\n  };\n\n  OnlineStateTracker.prototype.setAndBroadcast = function (newState) {\n    if (newState !== this.state) {\n      this.state = newState;\n      this.onlineStateHandler(newState);\n    }\n  };\n\n  OnlineStateTracker.prototype.logClientOfflineWarningIfNecessary = function () {\n    if (this.shouldWarnClientIsOffline) {\n      log.error('Could not reach Firestore backend.');\n      this.shouldWarnClientIsOffline = false;\n    }\n  };\n\n  OnlineStateTracker.prototype.clearOnlineStateTimer = function () {\n    if (this.onlineStateTimer !== null) {\n      this.onlineStateTimer.cancel();\n      this.onlineStateTimer = null;\n    }\n  };\n\n  return OnlineStateTracker;\n}();\n\nexport { OnlineStateTracker };","map":{"version":3,"sources":["../src/remote/online_state_tracker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OnlineState } from '../core/types';\nimport * as log from '../util/log';\nimport { assert } from '../util/assert';\nimport { AsyncQueue, TimerId } from '../util/async_queue';\nimport { CancelablePromise } from '../util/promise';\n\nconst LOG_TAG = 'OnlineStateTracker';\n\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\nconst MAX_WATCH_STREAM_FAILURES = 2;\n\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nexport class OnlineStateTracker {\n  /** The current OnlineState. */\n  private state = OnlineState.Unknown;\n\n  /**\n   * A count of consecutive failures to open the stream. If it reaches the\n   * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n   * Offline.\n   */\n  private watchStreamFailures = 0;\n\n  /**\n   * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n   * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n   * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n   */\n  private onlineStateTimer: CancelablePromise<void> | null = null;\n\n  /**\n   * Whether the client should log a warning message if it fails to connect to\n   * the backend (initially true, cleared after a successful stream, or if we've\n   * logged the message already).\n   */\n  private shouldWarnClientIsOffline = true;\n\n  constructor(\n    private asyncQueue: AsyncQueue,\n    private onlineStateHandler: (onlineState: OnlineState) => void\n  ) {}\n\n  /**\n   * Called by RemoteStore when a watch stream is started.\n   *\n   * It sets the OnlineState to Unknown and starts the onlineStateTimer\n   * if necessary.\n   */\n  handleWatchStreamStart(): void {\n    this.setAndBroadcast(OnlineState.Unknown);\n\n    if (this.onlineStateTimer === null) {\n      this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\n        TimerId.OnlineStateTimeout,\n        ONLINE_STATE_TIMEOUT_MS,\n        () => {\n          this.onlineStateTimer = null;\n          assert(\n            this.state === OnlineState.Unknown,\n            'Timer should be canceled if we transitioned to a different state.'\n          );\n          log.debug(\n            LOG_TAG,\n            `Watch stream didn't reach online or offline within ` +\n              `${ONLINE_STATE_TIMEOUT_MS}ms. Considering client offline.`\n          );\n          this.logClientOfflineWarningIfNecessary();\n          this.setAndBroadcast(OnlineState.Offline);\n\n          // NOTE: handleWatchStreamFailure() will continue to increment\n          // watchStreamFailures even though we are already marked Offline,\n          // but this is non-harmful.\n\n          return Promise.resolve();\n        }\n      );\n    }\n  }\n\n  /**\n   * Updates our OnlineState as appropriate after the watch stream reports a\n   * failure. The first failure moves us to the 'Unknown' state. We then may\n   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n   * actually transition to the 'Offline' state.\n   */\n  handleWatchStreamFailure(): void {\n    if (this.state === OnlineState.Online) {\n      this.setAndBroadcast(OnlineState.Unknown);\n    } else {\n      this.watchStreamFailures++;\n      if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n        this.clearOnlineStateTimer();\n        this.logClientOfflineWarningIfNecessary();\n        this.setAndBroadcast(OnlineState.Offline);\n      }\n    }\n  }\n\n  /**\n   * Explicitly sets the OnlineState to the specified state.\n   *\n   * Note that this resets our timers / failure counters, etc. used by our\n   * Offline heuristics, so must not be used in place of\n   * handleWatchStreamStart() and handleWatchStreamFailure().\n   */\n  set(newState: OnlineState): void {\n    this.clearOnlineStateTimer();\n    this.watchStreamFailures = 0;\n\n    if (newState === OnlineState.Online) {\n      // We've connected to watch at least once. Don't warn the developer\n      // about being offline going forward.\n      this.shouldWarnClientIsOffline = false;\n    }\n\n    this.setAndBroadcast(newState);\n  }\n\n  private setAndBroadcast(newState: OnlineState): void {\n    if (newState !== this.state) {\n      this.state = newState;\n      this.onlineStateHandler(newState);\n    }\n  }\n\n  private logClientOfflineWarningIfNecessary(): void {\n    if (this.shouldWarnClientIsOffline) {\n      log.error('Could not reach Firestore backend.');\n      this.shouldWarnClientIsOffline = false;\n    }\n  }\n\n  private clearOnlineStateTimer(): void {\n    if (this.onlineStateTimer !== null) {\n      this.onlineStateTimer.cancel();\n      this.onlineStateTimer = null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}