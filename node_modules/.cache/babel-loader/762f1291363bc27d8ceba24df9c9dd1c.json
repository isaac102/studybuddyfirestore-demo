{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { assert } from '../util/assert';\nimport { TimerId } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { ExponentialBackoff } from './backoff';\nimport { isNullOrUndefined } from '../util/types';\nvar LOG_TAG = 'PersistentStream';\nvar PersistentStreamState;\n\n(function (PersistentStreamState) {\n  /**\n   * The streaming RPC is not running and there's no error condition.\n   * Calling `start` will start the stream immediately without backoff.\n   * While in this state isStarted will return false.\n   */\n  PersistentStreamState[PersistentStreamState[\"Initial\"] = 0] = \"Initial\";\n  /**\n   * The stream is starting, and is waiting for an auth token to attach to\n   * the initial request. While in this state, isStarted will return\n   * true but isOpen will return false.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Auth\"] = 1] = \"Auth\";\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted and isOpen will return true.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Open\"] = 2] = \"Open\";\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   *\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Error\"] = 3] = \"Error\";\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After\n   * waiting is complete, the stream will try to open. While in this\n   * state isStarted() will return YES but isOpen will return false.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Backoff\"] = 4] = \"Backoff\";\n  /**\n   * The stream has been explicitly stopped; no further events will be emitted.\n   */\n\n  PersistentStreamState[PersistentStreamState[\"Stopped\"] = 5] = \"Stopped\";\n})(PersistentStreamState || (PersistentStreamState = {}));\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\n\n\nvar BACKOFF_INITIAL_DELAY_MS = 1000;\n/** Maximum backoff time in milliseconds */\n\nvar BACKOFF_MAX_DELAY_MS = 60 * 1000;\nvar BACKOFF_FACTOR = 1.5;\n/** The time a stream stays open after it is marked idle. */\n\nvar IDLE_TIMEOUT_MS = 60 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\n\nvar PersistentStream =\n/** @class */\nfunction () {\n  function PersistentStream(queue, connectionTimerId, idleTimerId, connection, credentialsProvider) {\n    this.queue = queue;\n    this.idleTimerId = idleTimerId;\n    this.connection = connection;\n    this.credentialsProvider = credentialsProvider;\n    this.inactivityTimerPromise = null;\n    this.stream = null;\n    this.listener = null;\n    this.backoff = new ExponentialBackoff(queue, connectionTimerId, BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);\n    this.state = PersistentStreamState.Initial;\n  }\n  /**\n   * Returns true if `start` has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n   * outbound requests.\n   */\n\n\n  PersistentStream.prototype.isStarted = function () {\n    return this.state === PersistentStreamState.Backoff || this.state === PersistentStreamState.Auth || this.state === PersistentStreamState.Open;\n  };\n  /**\n   * Returns true if the underlying RPC is open (the openHandler has been\n   * called) and the stream is ready for outbound requests.\n   */\n\n\n  PersistentStream.prototype.isOpen = function () {\n    return this.state === PersistentStreamState.Open;\n  };\n  /**\n   * Starts the RPC. Only allowed if isStarted returns false. The stream is\n   * not immediately ready for use: onOpen will be invoked when the RPC is ready\n   * for outbound requests, at which point isOpen will return true.\n   *\n   *  When start returns, isStarted will return true.\n   */\n\n\n  PersistentStream.prototype.start = function (listener) {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff(listener);\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Initial, 'Already started');\n    this.listener = listener;\n    this.auth();\n  };\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted state.\n   *\n   * When stop returns, isStarted and isOpen will both return false.\n   */\n\n\n  PersistentStream.prototype.stop = function () {\n    if (this.isStarted()) {\n      this.close(PersistentStreamState.Stopped);\n    }\n  };\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose function. That function can decide to\n   * inhibit backoff if required.\n   */\n\n\n  PersistentStream.prototype.inhibitBackoff = function () {\n    assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  };\n  /**\n   * Marks this stream as idle. If no further actions are performed on the\n   * stream for one minute, the stream will automatically close itself and\n   * notify the stream's onClose() handler with Status.OK. The stream will then\n   * be in a !isStarted() state, requiring the caller to start the stream again\n   * before further use.\n   *\n   * Only streams that are in state 'Open' can be marked idle, as all other\n   * states imply pending network operations.\n   */\n\n\n  PersistentStream.prototype.markIdle = function () {\n    var _this = this; // Starts the idle time if we are in state 'Open' and are not yet already\n    // running a timer (in which case the previous idle timeout still applies).\n\n\n    if (this.isOpen() && this.inactivityTimerPromise === null) {\n      this.inactivityTimerPromise = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function () {\n        return _this.handleIdleCloseTimer();\n      });\n    }\n  };\n  /** Sends a message to the underlying stream. */\n\n\n  PersistentStream.prototype.sendRequest = function (msg) {\n    this.cancelIdleCheck();\n    this.stream.send(msg);\n  };\n  /** Called by the idle timer when the stream should close due to inactivity. */\n\n\n  PersistentStream.prototype.handleIdleCloseTimer = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        if (this.isOpen()) {\n          // When timing out an idle stream there's no reason to force the stream into backoff when\n          // it restarts so set the stream state to Initial instead of Error.\n          return [2\n          /*return*/\n          , this.close(PersistentStreamState.Initial)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /** Marks the stream as active again. */\n\n\n  PersistentStream.prototype.cancelIdleCheck = function () {\n    if (this.inactivityTimerPromise) {\n      this.inactivityTimerPromise.cancel();\n      this.inactivityTimerPromise = null;\n    }\n  };\n  /**\n   * Closes the stream and cleans up as necessary:\n   *\n   * * closes the underlying GRPC stream;\n   * * calls the onClose handler with the given 'error';\n   * * sets internal stream state to 'finalState';\n   * * adjusts the backoff timer based on the error\n   *\n   * A new stream can be opened by calling `start` unless `finalState` is set to\n   * `PersistentStreamState.Stopped`.\n   *\n   * @param finalState the intended state of the stream after closing.\n   * @param error the error the connection was closed with.\n   */\n\n\n  PersistentStream.prototype.close = function (finalState, error) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var listener;\n      return tslib_1.__generator(this, function (_a) {\n        assert(finalState === PersistentStreamState.Error || isNullOrUndefined(error), \"Can't provide an error when not in an error state.\"); // The stream will be closed so we don't need our idle close timer anymore.\n\n        this.cancelIdleCheck(); // Ensure we don't leave a pending backoff operation queued (in case close()\n        // was called while we were waiting to reconnect).\n\n        this.backoff.cancel();\n\n        if (finalState !== PersistentStreamState.Error) {\n          // If this is an intentional close ensure we don't delay our next connection attempt.\n          this.backoff.reset();\n        } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n          // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n          log.error(error.toString());\n          log.error('Using maximum backoff delay to prevent overloading the backend.');\n          this.backoff.resetToMax();\n        } // Clean up the underlying stream because we are no longer interested in events.\n\n\n        if (this.stream !== null) {\n          this.tearDown();\n          this.stream.close();\n          this.stream = null;\n        } // This state must be assigned before calling onClose() to allow the callback to\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\n\n\n        this.state = finalState;\n        listener = this.listener; // Clear the listener to avoid bleeding of events from the underlying streams.\n\n        this.listener = null; // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it\n        // could trigger undesirable recovery logic, etc.).\n\n        if (finalState !== PersistentStreamState.Stopped) {\n          return [2\n          /*return*/\n          , listener.onClose(error)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\n   * Can be overridden to perform additional cleanup before the stream is closed.\n   * Calling super.tearDown() is not required.\n   */\n\n\n  PersistentStream.prototype.tearDown = function () {};\n\n  PersistentStream.prototype.auth = function () {\n    var _this = this;\n\n    assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');\n    this.state = PersistentStreamState.Auth;\n    this.credentialsProvider.getToken(\n    /*forceRefresh=*/\n    false).then(function (token) {\n      // Normally we'd have to schedule the callback on the AsyncQueue.\n      // However, the following calls are safe to be called outside the\n      // AsyncQueue since they don't chain asynchronous calls\n      _this.startStream(token);\n    }, function (error) {\n      _this.queue.enqueue(function () {\n        return tslib_1.__awaiter(_this, void 0, void 0, function () {\n          var rpcError;\n          return tslib_1.__generator(this, function (_a) {\n            if (this.state !== PersistentStreamState.Stopped) {\n              rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n              return [2\n              /*return*/\n              , this.handleStreamClose(rpcError)];\n            }\n\n            return [2\n            /*return*/\n            ];\n          });\n        });\n      });\n    });\n  };\n\n  PersistentStream.prototype.startStream = function (token) {\n    var _this = this;\n\n    if (this.state === PersistentStreamState.Stopped) {\n      // Stream can be stopped while waiting for authorization.\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state'); // Helper function to dispatch to AsyncQueue and make sure that any\n    // close will seem instantaneous and events are prevented from being\n    // raised after the close call\n\n    var dispatchIfStillActive = function (stream, fn) {\n      _this.queue.enqueue(function () {\n        return tslib_1.__awaiter(_this, void 0, void 0, function () {\n          return tslib_1.__generator(this, function (_a) {\n            // Only raise events if the stream instance has not changed\n            if (this.stream === stream) {\n              return [2\n              /*return*/\n              , fn()];\n            }\n\n            return [2\n            /*return*/\n            ];\n          });\n        });\n      });\n    }; // Only start stream if listener has not changed\n\n\n    if (this.listener !== null) {\n      var currentStream_1 = this.startRpc(token);\n      this.stream = currentStream_1;\n      this.stream.onOpen(function () {\n        dispatchIfStillActive(currentStream_1, function () {\n          assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);\n          _this.state = PersistentStreamState.Open;\n          return _this.listener.onOpen();\n        });\n      });\n      this.stream.onClose(function (error) {\n        dispatchIfStillActive(currentStream_1, function () {\n          return _this.handleStreamClose(error);\n        });\n      });\n      this.stream.onMessage(function (msg) {\n        dispatchIfStillActive(currentStream_1, function () {\n          return _this.onMessage(msg);\n        });\n      });\n    }\n  };\n\n  PersistentStream.prototype.performBackoff = function (listener) {\n    var _this = this;\n\n    assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');\n    this.state = PersistentStreamState.Backoff;\n    this.backoff.backoffAndRun(function () {\n      return tslib_1.__awaiter(_this, void 0, void 0, function () {\n        return tslib_1.__generator(this, function (_a) {\n          if (this.state === PersistentStreamState.Stopped) {\n            // We should have canceled the backoff timer when the stream was\n            // closed, but just in case we make this a no-op.\n            return [2\n            /*return*/\n            ];\n          }\n\n          this.state = PersistentStreamState.Initial;\n          this.start(listener);\n          assert(this.isStarted(), 'PersistentStream should have started');\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    });\n  };\n\n  PersistentStream.prototype.handleStreamClose = function (error) {\n    assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n    log.debug(LOG_TAG, \"close with error: \" + error);\n    this.stream = null; // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n\n    return this.close(PersistentStreamState.Error, error);\n  };\n\n  return PersistentStream;\n}();\n\nexport { PersistentStream };\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\n\nvar PersistentListenStream =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PersistentListenStream, _super);\n\n  function PersistentListenStream(queue, connection, credentials, serializer) {\n    var _this = _super.call(this, queue, TimerId.ListenStreamConnectionBackoff, TimerId.ListenStreamIdle, connection, credentials) || this;\n\n    _this.serializer = serializer;\n    return _this;\n  }\n\n  PersistentListenStream.prototype.startRpc = function (token) {\n    return this.connection.openStream('Listen', token);\n  };\n\n  PersistentListenStream.prototype.onMessage = function (watchChangeProto) {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n    var watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);\n    return this.listener.onWatchChange(watchChange, snapshot);\n  };\n  /**\n   * Registers interest in the results of the given query. If the query\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the query will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n\n\n  PersistentListenStream.prototype.watch = function (queryData) {\n    var request = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(queryData);\n    var labels = this.serializer.toListenRequestLabels(queryData);\n\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.sendRequest(request);\n  };\n  /**\n   * Unregisters interest in the results of the query associated with the\n   * given targetId.\n   */\n\n\n  PersistentListenStream.prototype.unwatch = function (targetId) {\n    var request = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.sendRequest(request);\n  };\n\n  return PersistentListenStream;\n}(PersistentStream);\n\nexport { PersistentListenStream };\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\n\nvar PersistentWriteStream =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PersistentWriteStream, _super);\n\n  function PersistentWriteStream(queue, connection, credentials, serializer) {\n    var _this = _super.call(this, queue, TimerId.WriteStreamConnectionBackoff, TimerId.WriteStreamIdle, connection, credentials) || this;\n\n    _this.serializer = serializer;\n    _this.handshakeComplete_ = false;\n    return _this;\n  }\n\n  Object.defineProperty(PersistentWriteStream.prototype, \"handshakeComplete\", {\n    /**\n     * Tracks whether or not a handshake has been successfully exchanged and\n     * the stream is ready to accept mutations.\n     */\n    get: function () {\n      return this.handshakeComplete_;\n    },\n    enumerable: true,\n    configurable: true\n  }); // Override of PersistentStream.start\n\n  PersistentWriteStream.prototype.start = function (listener) {\n    this.handshakeComplete_ = false;\n\n    _super.prototype.start.call(this, listener);\n  };\n\n  PersistentWriteStream.prototype.tearDown = function () {\n    if (this.handshakeComplete_) {\n      this.writeMutations([]);\n    }\n  };\n\n  PersistentWriteStream.prototype.startRpc = function (token) {\n    return this.connection.openStream('Write', token);\n  };\n\n  PersistentWriteStream.prototype.onMessage = function (responseProto) {\n    // Always capture the last stream token.\n    assert(!!responseProto.streamToken, 'Got a write response without a stream token');\n    this.lastStreamToken = responseProto.streamToken;\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');\n      this.handshakeComplete_ = true;\n      return this.listener.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n      var results = this.serializer.fromWriteResults(responseProto.writeResults);\n      var commitVersion = this.serializer.fromVersion(responseProto.commitTime);\n      return this.listener.onMutationResult(commitVersion, results);\n    }\n  };\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n\n\n  PersistentWriteStream.prototype.writeHandshake = function () {\n    assert(this.isOpen(), 'Writing handshake requires an opened stream');\n    assert(!this.handshakeComplete_, 'Handshake already completed'); // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n\n    var request = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.sendRequest(request);\n  };\n  /** Sends a group of mutations to the Firestore backend to apply. */\n\n\n  PersistentWriteStream.prototype.writeMutations = function (mutations) {\n    var _this = this;\n\n    assert(this.isOpen(), 'Writing mutations requires an opened stream');\n    assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');\n    assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');\n    var request = {\n      // Protos are typed with string, but we support UInt8Array on Node\n      // tslint:disable-next-line:no-any\n      streamToken: this.lastStreamToken,\n      writes: mutations.map(function (mutation) {\n        return _this.serializer.toMutation(mutation);\n      })\n    };\n    this.sendRequest(request);\n  };\n\n  return PersistentWriteStream;\n}(PersistentStream);\n\nexport { PersistentWriteStream };","map":{"version":3,"sources":["../src/remote/persistent_stream.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { CredentialsProvider, Token } from '../api/credentials';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ProtoByteString, TargetId } from '../core/types';\nimport { QueryData } from '../local/query_data';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport { assert } from '../util/assert';\nimport { AsyncQueue, TimerId } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\n\nimport { ExponentialBackoff } from './backoff';\nimport { Connection, Stream } from './connection';\nimport { JsonProtoSerializer } from './serializer';\nimport { WatchChange } from './watch_change';\nimport { isNullOrUndefined } from '../util/types';\nimport { CancelablePromise } from '../util/promise';\n\nconst LOG_TAG = 'PersistentStream';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface ListenRequest extends api.ListenRequest {\n  database?: string;\n}\nexport interface WriteRequest extends api.WriteRequest {\n  database?: string;\n}\n\nenum PersistentStreamState {\n  /**\n   * The streaming RPC is not running and there's no error condition.\n   * Calling `start` will start the stream immediately without backoff.\n   * While in this state isStarted will return false.\n   */\n  Initial,\n\n  /**\n   * The stream is starting, and is waiting for an auth token to attach to\n   * the initial request. While in this state, isStarted will return\n   * true but isOpen will return false.\n   */\n  Auth,\n\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted and isOpen will return true.\n   */\n  Open,\n\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   *\n   */\n  Error,\n\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After\n   * waiting is complete, the stream will try to open. While in this\n   * state isStarted() will return YES but isOpen will return false.\n   */\n  Backoff,\n\n  /**\n   * The stream has been explicitly stopped; no further events will be emitted.\n   */\n  Stopped\n}\n\n/**\n * Provides a common interface that is shared by the listeners for stream\n * events by the concrete implementation classes.\n */\nexport interface PersistentStreamListener {\n  /**\n   * Called after the stream was established and can accept outgoing\n   * messages\n   */\n  onOpen: () => Promise<void>;\n  /**\n   * Called after the stream has closed. If there was an error, the\n   * FirestoreError will be set.\n   */\n  onClose: (err?: FirestoreError) => Promise<void>;\n}\n\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst BACKOFF_INITIAL_DELAY_MS = 1000;\n\n/** Maximum backoff time in milliseconds */\nconst BACKOFF_MAX_DELAY_MS = 60 * 1000;\n\nconst BACKOFF_FACTOR = 1.5;\n\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nexport abstract class PersistentStream<\n  SendType,\n  ReceiveType,\n  ListenerType extends PersistentStreamListener\n> {\n  private state: PersistentStreamState;\n  private inactivityTimerPromise: CancelablePromise<void> | null = null;\n  private stream: Stream<SendType, ReceiveType> | null = null;\n\n  protected backoff: ExponentialBackoff;\n\n  protected listener: ListenerType | null = null;\n\n  constructor(\n    private queue: AsyncQueue,\n    connectionTimerId: TimerId,\n    private idleTimerId: TimerId,\n    protected connection: Connection,\n    private credentialsProvider: CredentialsProvider\n  ) {\n    this.backoff = new ExponentialBackoff(\n      queue,\n      connectionTimerId,\n      BACKOFF_INITIAL_DELAY_MS,\n      BACKOFF_FACTOR,\n      BACKOFF_MAX_DELAY_MS\n    );\n    this.state = PersistentStreamState.Initial;\n  }\n\n  /**\n   * Returns true if `start` has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n   * outbound requests.\n   */\n  isStarted(): boolean {\n    return (\n      this.state === PersistentStreamState.Backoff ||\n      this.state === PersistentStreamState.Auth ||\n      this.state === PersistentStreamState.Open\n    );\n  }\n\n  /**\n   * Returns true if the underlying RPC is open (the openHandler has been\n   * called) and the stream is ready for outbound requests.\n   */\n  isOpen(): boolean {\n    return this.state === PersistentStreamState.Open;\n  }\n\n  /**\n   * Starts the RPC. Only allowed if isStarted returns false. The stream is\n   * not immediately ready for use: onOpen will be invoked when the RPC is ready\n   * for outbound requests, at which point isOpen will return true.\n   *\n   *  When start returns, isStarted will return true.\n   */\n  start(listener: ListenerType): void {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff(listener);\n      return;\n    }\n\n    assert(this.state === PersistentStreamState.Initial, 'Already started');\n    this.listener = listener;\n    this.auth();\n  }\n\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted state.\n   *\n   * When stop returns, isStarted and isOpen will both return false.\n   */\n  stop(): void {\n    if (this.isStarted()) {\n      this.close(PersistentStreamState.Stopped);\n    }\n  }\n\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose function. That function can decide to\n   * inhibit backoff if required.\n   */\n  inhibitBackoff(): void {\n    assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  }\n\n  /**\n   * Marks this stream as idle. If no further actions are performed on the\n   * stream for one minute, the stream will automatically close itself and\n   * notify the stream's onClose() handler with Status.OK. The stream will then\n   * be in a !isStarted() state, requiring the caller to start the stream again\n   * before further use.\n   *\n   * Only streams that are in state 'Open' can be marked idle, as all other\n   * states imply pending network operations.\n   */\n  markIdle(): void {\n    // Starts the idle time if we are in state 'Open' and are not yet already\n    // running a timer (in which case the previous idle timeout still applies).\n    if (this.isOpen() && this.inactivityTimerPromise === null) {\n      this.inactivityTimerPromise = this.queue.enqueueAfterDelay(\n        this.idleTimerId,\n        IDLE_TIMEOUT_MS,\n        () => this.handleIdleCloseTimer()\n      );\n    }\n  }\n\n  /** Sends a message to the underlying stream. */\n  protected sendRequest(msg: SendType): void {\n    this.cancelIdleCheck();\n    this.stream!.send(msg);\n  }\n\n  /** Called by the idle timer when the stream should close due to inactivity. */\n  private async handleIdleCloseTimer(): Promise<void> {\n    if (this.isOpen()) {\n      // When timing out an idle stream there's no reason to force the stream into backoff when\n      // it restarts so set the stream state to Initial instead of Error.\n      return this.close(PersistentStreamState.Initial);\n    }\n  }\n\n  /** Marks the stream as active again. */\n  private cancelIdleCheck() {\n    if (this.inactivityTimerPromise) {\n      this.inactivityTimerPromise.cancel();\n      this.inactivityTimerPromise = null;\n    }\n  }\n\n  /**\n   * Closes the stream and cleans up as necessary:\n   *\n   * * closes the underlying GRPC stream;\n   * * calls the onClose handler with the given 'error';\n   * * sets internal stream state to 'finalState';\n   * * adjusts the backoff timer based on the error\n   *\n   * A new stream can be opened by calling `start` unless `finalState` is set to\n   * `PersistentStreamState.Stopped`.\n   *\n   * @param finalState the intended state of the stream after closing.\n   * @param error the error the connection was closed with.\n   */\n  private async close(\n    finalState: PersistentStreamState,\n    error?: FirestoreError\n  ): Promise<void> {\n    assert(\n      finalState === PersistentStreamState.Error || isNullOrUndefined(error),\n      \"Can't provide an error when not in an error state.\"\n    );\n\n    // The stream will be closed so we don't need our idle close timer anymore.\n    this.cancelIdleCheck();\n\n    // Ensure we don't leave a pending backoff operation queued (in case close()\n    // was called while we were waiting to reconnect).\n    this.backoff.cancel();\n\n    if (finalState !== PersistentStreamState.Error) {\n      // If this is an intentional close ensure we don't delay our next connection attempt.\n      this.backoff.reset();\n    } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n      // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n      log.error(error.toString());\n      log.error(\n        'Using maximum backoff delay to prevent overloading the backend.'\n      );\n      this.backoff.resetToMax();\n    }\n\n    // Clean up the underlying stream because we are no longer interested in events.\n    if (this.stream !== null) {\n      this.tearDown();\n      this.stream.close();\n      this.stream = null;\n    }\n\n    // This state must be assigned before calling onClose() to allow the callback to\n    // inhibit backoff or otherwise manipulate the state in its non-started state.\n    this.state = finalState;\n    const listener = this.listener!;\n\n    // Clear the listener to avoid bleeding of events from the underlying streams.\n    this.listener = null;\n\n    // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it\n    // could trigger undesirable recovery logic, etc.).\n    if (finalState !== PersistentStreamState.Stopped) {\n      return listener.onClose(error);\n    }\n  }\n\n  /**\n   * Can be overridden to perform additional cleanup before the stream is closed.\n   * Calling super.tearDown() is not required.\n   */\n  protected tearDown(): void {}\n\n  /**\n   * Used by subclasses to start the concrete RPC and return the underlying\n   * connection stream.\n   */\n  protected abstract startRpc(\n    token: Token | null\n  ): Stream<SendType, ReceiveType>;\n\n  /**\n   * Called after the stream has received a message. The function will be\n   * called on the right queue and must return a Promise.\n   * @param message The message received from the stream.\n   */\n  protected abstract onMessage(message: ReceiveType): Promise<void>;\n\n  private auth(): void {\n    assert(\n      this.state === PersistentStreamState.Initial,\n      'Must be in initial state to auth'\n    );\n\n    this.state = PersistentStreamState.Auth;\n\n    this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(\n      token => {\n        // Normally we'd have to schedule the callback on the AsyncQueue.\n        // However, the following calls are safe to be called outside the\n        // AsyncQueue since they don't chain asynchronous calls\n        this.startStream(token);\n      },\n      (error: Error) => {\n        this.queue.enqueue(async () => {\n          if (this.state !== PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            const rpcError = new FirestoreError(\n              Code.UNKNOWN,\n              'Fetching auth token failed: ' + error.message\n            );\n            return this.handleStreamClose(rpcError);\n          }\n        });\n      }\n    );\n  }\n\n  private startStream(token: Token | null): void {\n    if (this.state === PersistentStreamState.Stopped) {\n      // Stream can be stopped while waiting for authorization.\n      return;\n    }\n\n    assert(\n      this.state === PersistentStreamState.Auth,\n      'Trying to start stream in a non-auth state'\n    );\n    // Helper function to dispatch to AsyncQueue and make sure that any\n    // close will seem instantaneous and events are prevented from being\n    // raised after the close call\n    const dispatchIfStillActive = (\n      stream: Stream<SendType, ReceiveType>,\n      fn: () => Promise<void>\n    ) => {\n      this.queue.enqueue(async () => {\n        // Only raise events if the stream instance has not changed\n        if (this.stream === stream) {\n          return fn();\n        }\n      });\n    };\n\n    // Only start stream if listener has not changed\n    if (this.listener !== null) {\n      const currentStream = this.startRpc(token);\n      this.stream = currentStream;\n      this.stream.onOpen(() => {\n        dispatchIfStillActive(currentStream, () => {\n          assert(\n            this.state === PersistentStreamState.Auth,\n            'Expected stream to be in state auth, but was ' + this.state\n          );\n          this.state = PersistentStreamState.Open;\n          return this.listener!.onOpen();\n        });\n      });\n      this.stream.onClose((error: FirestoreError) => {\n        dispatchIfStillActive(currentStream, () => {\n          return this.handleStreamClose(error);\n        });\n      });\n      this.stream.onMessage((msg: ReceiveType) => {\n        dispatchIfStillActive(currentStream, () => {\n          return this.onMessage(msg);\n        });\n      });\n    }\n  }\n\n  private performBackoff(listener: ListenerType): void {\n    assert(\n      this.state === PersistentStreamState.Error,\n      'Should only perform backoff in an error case'\n    );\n    this.state = PersistentStreamState.Backoff;\n\n    this.backoff.backoffAndRun(async () => {\n      if (this.state === PersistentStreamState.Stopped) {\n        // We should have canceled the backoff timer when the stream was\n        // closed, but just in case we make this a no-op.\n        return;\n      }\n\n      this.state = PersistentStreamState.Initial;\n      this.start(listener);\n      assert(this.isStarted(), 'PersistentStream should have started');\n    });\n  }\n\n  private handleStreamClose(error?: FirestoreError): Promise<void> {\n    assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n    log.debug(LOG_TAG, `close with error: ${error}`);\n\n    this.stream = null;\n\n    // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n    return this.close(PersistentStreamState.Error, error);\n  }\n}\n\n/** Listener for the PersistentWatchStream */\nexport interface WatchStreamListener extends PersistentStreamListener {\n  /**\n   * Called on a watchChange. The snapshot parameter will be MIN if the watch\n   * change did not have a snapshot associated with it.\n   */\n  onWatchChange: (\n    watchChange: WatchChange,\n    snapshot: SnapshotVersion\n  ) => Promise<void>;\n}\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nexport class PersistentListenStream extends PersistentStream<\n  api.ListenRequest,\n  api.ListenResponse,\n  WatchStreamListener\n> {\n  constructor(\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer\n  ) {\n    super(\n      queue,\n      TimerId.ListenStreamConnectionBackoff,\n      TimerId.ListenStreamIdle,\n      connection,\n      credentials\n    );\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.ListenRequest, api.ListenResponse> {\n    return this.connection.openStream<api.ListenRequest, api.ListenResponse>(\n      'Listen',\n      token\n    );\n  }\n\n  protected onMessage(watchChangeProto: api.ListenResponse): Promise<void> {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n\n    const watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    const snapshot = this.serializer.versionFromListenResponse(\n      watchChangeProto\n    );\n    return this.listener!.onWatchChange(watchChange, snapshot);\n  }\n\n  /**\n   * Registers interest in the results of the given query. If the query\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the query will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n  watch(queryData: QueryData): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(queryData);\n\n    const labels = this.serializer.toListenRequestLabels(queryData);\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.sendRequest(request);\n  }\n\n  /**\n   * Unregisters interest in the results of the query associated with the\n   * given targetId.\n   */\n  unwatch(targetId: TargetId): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.sendRequest(request);\n  }\n}\n\n/** Listener for the PersistentWriteStream */\nexport interface WriteStreamListener extends PersistentStreamListener {\n  /**\n   * Called by the PersistentWriteStream upon a successful handshake response\n   * from the server, which is the receiver's cue to send any pending writes.\n   */\n  onHandshakeComplete: () => Promise<void>;\n\n  /**\n   * Called by the PersistentWriteStream upon receiving a StreamingWriteResponse\n   * from the server that contains a mutation result.\n   */\n  onMutationResult: (\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ) => Promise<void>;\n}\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nexport class PersistentWriteStream extends PersistentStream<\n  api.WriteRequest,\n  api.WriteResponse,\n  WriteStreamListener\n> {\n  private handshakeComplete_ = false;\n\n  constructor(\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer\n  ) {\n    super(\n      queue,\n      TimerId.WriteStreamConnectionBackoff,\n      TimerId.WriteStreamIdle,\n      connection,\n      credentials\n    );\n  }\n\n  /**\n   * The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   *\n   * PersistentWriteStream manages propagating this value from responses to the\n   * next request.\n   */\n  lastStreamToken: ProtoByteString;\n\n  /**\n   * Tracks whether or not a handshake has been successfully exchanged and\n   * the stream is ready to accept mutations.\n   */\n  get handshakeComplete(): boolean {\n    return this.handshakeComplete_;\n  }\n\n  // Override of PersistentStream.start\n  start(listener: WriteStreamListener): void {\n    this.handshakeComplete_ = false;\n    super.start(listener);\n  }\n\n  protected tearDown() {\n    if (this.handshakeComplete_) {\n      this.writeMutations([]);\n    }\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.WriteRequest, api.WriteResponse> {\n    return this.connection.openStream<api.WriteRequest, api.WriteResponse>(\n      'Write',\n      token\n    );\n  }\n\n  protected onMessage(responseProto: api.WriteResponse): Promise<void> {\n    // Always capture the last stream token.\n    assert(\n      !!responseProto.streamToken,\n      'Got a write response without a stream token'\n    );\n    this.lastStreamToken = responseProto.streamToken!;\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      assert(\n        !responseProto.writeResults || responseProto.writeResults.length === 0,\n        'Got mutation results for handshake'\n      );\n      this.handshakeComplete_ = true;\n      return this.listener!.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n\n      const results = this.serializer.fromWriteResults(\n        responseProto.writeResults\n      );\n      const commitVersion = this.serializer.fromVersion(\n        responseProto.commitTime!\n      );\n      return this.listener!.onMutationResult(commitVersion, results);\n    }\n  }\n\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n  writeHandshake(): void {\n    assert(this.isOpen(), 'Writing handshake requires an opened stream');\n    assert(!this.handshakeComplete_, 'Handshake already completed');\n    // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n    const request: WriteRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.sendRequest(request);\n  }\n\n  /** Sends a group of mutations to the Firestore backend to apply. */\n  writeMutations(mutations: Mutation[]): void {\n    assert(this.isOpen(), 'Writing mutations requires an opened stream');\n    assert(\n      this.handshakeComplete_,\n      'Handshake must be complete before writing mutations'\n    );\n    assert(\n      this.lastStreamToken.length > 0,\n      'Trying to write mutation without a token'\n    );\n\n    const request: WriteRequest = {\n      // Protos are typed with string, but we support UInt8Array on Node\n      // tslint:disable-next-line:no-any\n      streamToken: this.lastStreamToken as any,\n      writes: mutations.map(mutation => this.serializer.toMutation(mutation))\n    };\n\n    this.sendRequest(request);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}